## 📝두 큐 합 같게 만들기
##### 알고리즘 구상
- 각 큐의 원소 합을 같게 만들기 위해 필요한 작업의 최소 횟수 -> 그리디 사용?
- 언제가 최악의 경우인지에 대한 기준 -> 큐 길이만큼 한 번 더 돌면?
- 작업 횟수: 특정 큐에 insert하는 경우만 카운트
- 두 큐 중 합이 더 큰 큐에서만 계속 pop이 발생할 것


##### 참고 자료
https://computer-science-student.tistory.com/79

##### 문제 풀이
- 최악의 횟수를 기준으로 반복문을 돌면서 두 큐의 총합이 같은지를 비교
-> 같아지면 바로 횟수 반환
-> 다르면 총합이 더 큰 큐에서 원소를 빼서 다른 큐에 넣음
- 반복문이 다 끝나도 두 큐의 원소 총합이 같지 않으면 -1 반환

---
## 📝주차 요금 계산
##### 알고리즘 구상
- records 문자열을 stringstream을 이용해 시각, 차량 번호, 내역을 각각 변수에 저장
- 차량 번호와 매칭되어야하는 값은 입차시간과 주차 이용 시간 -> map으로 key-value값 저장
- 내역이 IN 이냐 OUT이냐에 따라 입차시간에 넣냐 주차 이용 시간을 계산하냐를 나눔
- 출차내역이 없는 경우 출차 시간 23:59로 계산해서 임의로 주차 이용 시간 계산

##### 참고 자료
https://baebalja.tistory.com/6

##### 문제 풀이
- 실패

---
## 📝연속된 부분 수열의 합
##### 알고리즘 구상
- 비내림차순 = 오름차순
- start, end 포인트를 움직여주면서 그 사이의 합들이 k와 같도록 만들어주며 이 start부터 end 까지의 길이가 짧은 수열을 찾음
- 길이가 짧은 수열이 여러 개인 경우 앞쪽(시작 인덱스가 작은)에 나오는 수열을 찾음

##### 참고 자료
https://aerospacekim.tistory.com/79

https://velog.io/@heyggun/Algorithm-Two-Pointers-Algorithm-%ED%88%AC-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98

##### 문제 풀이
- 처음과 시작 포인트까지의 합 < k: 끝 포인터를 증가시켜 sum의 값을 증가
- 처음과 시작 포인트까지의 합 > k: 시작 포인터를 증가시켜 sum의 값을 감소
- 처음과 시작 포인트까지의 합 == k: 현재까지 길이가 가장 짧은 부분 수열의 start, end로 교체

---
## 📝삼각 달팽이
##### 알고리즘 구상
- 달팽이 모양으로 채워나갈 때의 규칙: 아래로 이동/오른쪽으로이동/위로이동
- 2차원 배열을 이용해서 아래/오른쪽/위(대각선) 위치에 배열을 채움

##### 참고 자료
![image](https://github.com/KangJiUng/algorithm_solutions/assets/107825793/f8be7858-5651-490f-a80f-0819a577bcf8)


##### 문제 풀이
- 2차원 배열을 이용
-> 아래로 이동 시 행인덱스 +1하며 숫자를 채움
-> 오른쪽으로 이동 시 열인덱스 +1 하며 숫자를 채움
-> 대각선 위로 이동 시 행/열인덱스 -1 하며 숫자를 채움
- 초기화해둔 수(0)이면 숫자를 채워넣고 다른 숫자가 있다면 그 전 칸으로 이동
